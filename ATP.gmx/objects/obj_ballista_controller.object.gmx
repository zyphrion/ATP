<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///constructor code
init = false;

owner = 0;

//initial anchor points
//The controller object is the center of the base to start, though I want to play with it staying attached there
//each objects x/y will be the base on the center of gravity, or pivot point for each piece
base_x = x;
base_y = y;
front_wheel_x = x+21;
front_wheel_y = y;
back_wheel_x = x-22;
back_wheel_y = y;
anchor_x = x-22;
anchor_y = y;
arm_x = x-22;
arm_y = y-13;
loader_x = x-22;
loader_y = y-13;

//Control Flags
input_state = 0;
fire = 0;
firing = 0;
reload = 0;
reloading = 0;
cock = 0;
cocking = 0;
cocked = 0;
fully_cocked = 0;
angle_change = 0;
move = 0;
moving = 0;

//Material and Construction Type
base_type = 0;
wheel_type = 0;
arm_type = 0;
loader_type = 0;
anchor_type = 0;
spring_type = 0;

//property variables
aim_angle = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialization and Creation
if(!init)
{
    front_wheel = instance_create(front_wheel_x,front_wheel_y, obj_ballista_front_wheel);
    front_wheel.owner = id;
    back_wheel = instance_create(back_wheel_x,back_wheel_y, obj_ballista_back_wheel);
    back_wheel.owner = id;
    base = instance_create(base_x,base_y, obj_ballista_base);
    base.owner = id;
    arm = instance_create(arm_x,arm_y, obj_ballista_arm);
    arm.owner = id;
    loader = instance_create(loader_x,loader_y, obj_ballista_loader);
    loader.owner = id;
    anchor = instance_create(anchor_x,anchor_y, obj_ballista_anchor);
    anchor.owner = id;
    init = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Reconciling Changes
base_x = x;
base_y = y;
front_wheel_x = x+21;
front_wheel_y = y;
back_wheel_x = x-22;
back_wheel_y = y;
anchor_x = x-22;
anchor_y = y;
arm_x = x-22;
arm_y = y-13;
loader_x = x-22;
loader_y = y-13;

//testing to verify all of the built in attachments are correct
/*base.x = base_x;
base.y = base_y;
front_wheel.x = base.front_wheel_x;
front_wheel.y = base.front_wheel_y;
anchor.x = base.anchor_x;
anchor.y = base.anchor_y;
arm.x = anchor.arm_x;
arm.y = anchor.arm_y;
loader.x = arm.loader_stop_0_x;
loader.y = arm.loader_stop_0_y;
*/

with(arm)
{
    if(direction != owner.aim_angle)//if the angle changes
    {
        direction = owner.aim_angle;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Control Switch
//This control switch will interpret commands from the player/ai controller that owns it
switch(input_state)
{
    case 0:
    change_angle = 0;
    fire = 0;
    reload = 0;
    break;
    case 1: change_angle = 1;
        show_debug_message("W");
        break;
    case 2: change_angle = -1;
        show_debug_message("S");
        break;
    case 3:;break;
    case 4:;break;
    case 5:fire = 1;break;
    case 6:reload = 1;
    case 7:;break;
    case 8:;break;
    case 9:;break;
    default:
    change_angle = 0;
    fire = 0;
    reload = 0;
    ;break;
    
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Control Structure
/*
cannot adjust aiming angle while performing any other action
cannot cock weapon while performing any other action
*/
//angle change
if(!moving)//can only adjust angle, reload, fire, or cock weapon if it is stationary
{
    if(!firing &amp;&amp; !cocking &amp;&amp; !reloading)
    {
        if(change_angle == 1 &amp;&amp; arm.direction &lt; 90)
        {
            aim_angle++;
        }
        else if(change_angle == -1 &amp;&amp; arm.direction &gt; 0)
        {
            aim_angle--;
        }
        else//do nothing
        {}
    }
    else if(fire)
    {
        if(cocked)
        {
            firing = true;
        }
        else//cannot fire uncocked weapon
        {
            firing = false;
        }
    }
    else if(cock)
    {
        if(!fully_cocked &amp;&amp; !firing)
        {
            cocking = true;
        }
        else//cannot cock a weapon that is fully cocked or firing
        {
            cocking = false;
        }
    }
    else if(reload)
    {
        if(cocked &amp;&amp; !firing)
        {
            reloading = true;
        }
        else//cannot reload a weapon thats not cocked or is firing
        {
            reloading = false;
        }
    }
    if(change_angle == 0)
    {
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///collision checking code
//this code will calculate the next position/movement path of the object for use in collision detection
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
